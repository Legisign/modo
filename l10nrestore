#!/bin/zsh
#
# l10nrestore -- restore an .mo or a .qm file from a numbered backup
#
# 2016-09-13    Initial Python version. (TN)
# 2020-01-15    Conversion to zsh. (TN)

emulate -L zsh

declare -a backups
declare f dryrun prg stepvar verbose
integer point steps

zparseopts -D n=dryrun s:=stepvar v=verbose
(( $#stepvar > 1 )) && steps=${stepvar[2]} || steps=1

if (( $# == 0 )); then
    cat <<EOF
${0:t} -- palauta .mo- tai .qm-tiedosto varmuuskopiosta

Käyttö:
    ${0:t} [ -n -s N -v ] tiedosto...

Valitsimet:
    -n    näytä mitä tapahtuisi tekemättä mitään
    -s N  palaa takaisin N askelta (oletus: 1)
    -v    näytä yksityiskohtaisempaa tietoa

EOF
    exit 1
fi

for f in $*; do
    if [[ $f != *.(mo|qm) ]]; then
        print -- ${0:t}: ei .mo- tai .qm-tiedosto, ohitetaan: $f 1>&2
        continue
    fi
    backups=( ${f}.~<->~ )
    if (( $#backups < steps )); then
        print -- ${0:t}: palautettavissa enintään $#backups askelta: $f 1>&2
        continue
    fi

    # 1) rename the latest .mo to put it out of the way
    if [[ -e $f.restore ]]; then
        print -- ${0:t}: on jo olemassa: $f.restore 1>&2
        continue
    fi
    [[ -n $verbose ]] && print -- 1 :: $f → $f.restore
    [[ -n $dryrun ]] || mv $f $f.restore || return 1

    # 2) rename the steps-level backup to .mo
    (( point=$#backups - steps + 1 ))
    [[ -n $verbose ]] && print -- 2 :: ${f}.~${point}~ → $f
    [[ -n $dryrun ]] || mv ${f}.~${point}~ $f || return 1

    # 3) remove newer levels
    if (( point < $#backups )); then
        [[ -n $verbose ]] && print -- 3 :: poistetaan ${f}.~{$(( point + 1 ))..$#backups}\~
        [[ -n $dryrun ]] || rm ${f}.~{$(( point + 1 ))..$#backups}~ || return 1
    elif [[ -n $verbose ]]; then
        print -- 3 :: \(ei uudempia poistettavia versioita\)
    fi

    # 4) remove the restoration backup
    [[ -n $verbose ]] && print -- 4 :: poistetaan ${f}.restore
    [[ -n $dryrun ]] || rm ${f}.restore
done
